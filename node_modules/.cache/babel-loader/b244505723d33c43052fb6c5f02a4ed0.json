{"ast":null,"code":"var _jsxFileName = \"/Users/suchangcao/study/Northeastern University/2022-9-07(Grad-2-2)/CS 5330/project/react-mediapipe-main/Real-time-American-Sign-language-recognition/src/components/MPHands.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useEffect, useState } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { Hands, HAND_CONNECTIONS } from \"@mediapipe/hands/hands\";\nimport { drawConnectors, drawLandmarks } from \"@mediapipe/drawing_utils/drawing_utils\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport score from \"./Output2\";\nimport pickledData from \"./model.p\"; // let word_dict={0: 'A', \n//                 1: 'B', \n//                 2: 'C', \n//                 3: 'D', \n//                 4: 'E', \n//                 5: 'F', \n//                 6: 'G', \n//                 7: 'H', \n//                 8: 'I', \n//                 9: 'J', \n//                 10: 'K', \n//                 11: 'L', \n//                 12: 'M', \n//                 13: 'N', \n//                 14: 'O', \n//                 15: 'P', \n//                 16: 'Q', \n//                 17: 'R', \n//                 18: 'S', \n//                 19: 'T', \n//                 20: 'U', \n//                 21: 'V', \n//                 22: 'W', \n//                 23: 'X', \n//                 24: 'Y', \n//                 25: 'Z'}\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet word_dict = {\n  0: 'A',\n  1: 'B',\n  2: 'K',\n  3: 'L',\n  4: 'M',\n  5: 'N',\n  6: 'O',\n  7: 'P',\n  8: 'Q',\n  9: 'R',\n  10: 'S',\n  11: 'T',\n  12: 'C',\n  13: 'U',\n  14: 'V',\n  15: 'W',\n  16: 'X',\n  17: 'Y',\n  18: 'Z',\n  19: 'D',\n  20: 'E',\n  21: 'F',\n  22: 'G',\n  23: 'H',\n  24: 'I',\n  25: 'J'\n};\n\nfunction getPredict(landmarks) {\n  // console.log(\"landmarks: \", landmarks)\n  // const nodePickle = require('node-pickle');\n  // nodePickle.load(pickledData)\n  var data_input = [];\n  var data_input_x = [];\n  var data_input_y = [];\n\n  for (var i in landmarks) {\n    // console.log()\n    var x = landmarks[i].x;\n    var y = landmarks[i].y;\n    data_input_x.push(x);\n    data_input_y.push(y);\n  }\n\n  for (var j in landmarks) {\n    var x = landmarks[j].x;\n    var y = landmarks[j].y; // console.log(x)\n    // console.log(Math.min(data_input_x))\n\n    data_input.push(x - Math.min(...data_input_x));\n    data_input.push(y - Math.min(...data_input_y));\n  } // console.log(data_input)\n\n\n  let pred = score(data_input);\n  let z = Math.max(...pred); // console.log()\n\n  let l = pred.indexOf(z); // console.log(word_dict[l])\n\n  return word_dict[l]; // console.log(pred)\n  // console.log(\"Prediction results:\",Math.round(pred));\n}\n\nfunction getHighest(prediction) {\n  for (let i in prediction) {\n    if (prediction[i] > 200) {\n      console.log(prediction[i]);\n    }\n  }\n}\n\nconst MPHands = () => {\n  _s();\n\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [isStart, setIsStart] = useState(false);\n  let time = {};\n  useEffect(() => {\n    console.log(Hands.VERSION);\n    const hands = new Hands({\n      locateFile: file => {\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1626903359/${file}`;\n      }\n    });\n    hands.setOptions({\n      maxNumHands: 2,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5\n    });\n    hands.onResults(onResults);\n\n    if (typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null) {\n      const camera = new Camera(webcamRef.current.video, {\n        onFrame: async () => {\n          await hands.send({\n            image: webcamRef.current.video\n          });\n        },\n        width: 1280,\n        height: 720\n      });\n      camera.start();\n    }\n  }, []);\n  let prediction = {};\n\n  const onResults = results => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, videoWidth, videoHeight);\n    canvasCtx.translate(videoWidth, 0);\n    canvasCtx.scale(-1, 1);\n    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);\n\n    if (results.multiHandLandmarks) {\n      for (const landmarks of results.multiHandLandmarks) {\n        let result = getPredict(landmarks);\n\n        if (result in prediction) {\n          prediction[result]++;\n        } else {\n          prediction[result] = 1;\n        }\n\n        for (let i in prediction) {\n          // console.log(prediction[i])\n          if (prediction[i] > 50) {\n            console.log(\"QQQQQQQQQQQQQ\", i); //在前端显示\n\n            prediction = {};\n            break;\n          }\n        }\n\n        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {\n          color: \"#00FF00\",\n          lineWidth: 5\n        });\n        drawLandmarks(canvasCtx, landmarks, {\n          color: \"#FFFFFF\",\n          lineWidth: 2\n        });\n      }\n    }\n\n    canvasCtx.restore();\n  };\n\n  const startCamera = () => {\n    console.log(\"enle!\");\n    setIsStart(true);\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [console.log(isStart), isStart ? /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        audio: false,\n        mirrored: true,\n        ref: webcamRef,\n        style: {\n          position: \"absolute\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          left: \"0\",\n          right: \"0\",\n          textAlign: \"center\",\n          zindex: 9,\n          width: 320,\n          height: 240\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 207,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        style: {\n          position: \"absolute\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          left: \"0\",\n          right: \"0\",\n          textAlign: \"center\",\n          zindex: 9,\n          width: 320,\n          height: 240\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 223,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 206,\n      columnNumber: 7\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 238,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startCamera,\n      children: \"Start camera\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 241,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 202,\n    columnNumber: 5\n  }, this);\n};\n\n_s(MPHands, \"YOCJ6J3T45X/43cjS8RZQCPmWag=\");\n\n_c = MPHands;\nexport default MPHands;\n\nvar _c;\n\n$RefreshReg$(_c, \"MPHands\");","map":{"version":3,"sources":["/Users/suchangcao/study/Northeastern University/2022-9-07(Grad-2-2)/CS 5330/project/react-mediapipe-main/Real-time-American-Sign-language-recognition/src/components/MPHands.js"],"names":["React","useRef","useEffect","useState","Webcam","Hands","HAND_CONNECTIONS","drawConnectors","drawLandmarks","Camera","score","pickledData","word_dict","getPredict","landmarks","data_input","data_input_x","data_input_y","i","x","y","push","j","Math","min","pred","z","max","l","indexOf","getHighest","prediction","console","log","MPHands","webcamRef","canvasRef","isStart","setIsStart","time","VERSION","hands","locateFile","file","setOptions","maxNumHands","minDetectionConfidence","minTrackingConfidence","onResults","current","camera","video","onFrame","send","image","width","height","start","results","videoWidth","videoHeight","canvasElement","canvasCtx","getContext","save","clearRect","translate","scale","drawImage","multiHandLandmarks","result","color","lineWidth","restore","startCamera","position","marginLeft","marginRight","left","right","textAlign","zindex"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect, useState  } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { Hands, HAND_CONNECTIONS } from \"@mediapipe/hands/hands\";\nimport {\n  drawConnectors,\n  drawLandmarks,\n} from \"@mediapipe/drawing_utils/drawing_utils\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport score from \"./Output2\"\nimport pickledData from \"./model.p\"\n\n\n// let word_dict={0: 'A', \n//                 1: 'B', \n//                 2: 'C', \n//                 3: 'D', \n//                 4: 'E', \n//                 5: 'F', \n//                 6: 'G', \n//                 7: 'H', \n//                 8: 'I', \n//                 9: 'J', \n//                 10: 'K', \n//                 11: 'L', \n//                 12: 'M', \n//                 13: 'N', \n//                 14: 'O', \n//                 15: 'P', \n//                 16: 'Q', \n//                 17: 'R', \n//                 18: 'S', \n//                 19: 'T', \n//                 20: 'U', \n//                 21: 'V', \n//                 22: 'W', \n//                 23: 'X', \n//                 24: 'Y', \n//                 25: 'Z'}\n\nlet word_dict = {\n  0: 'A',\n  1: 'B',\n  2: 'K',\n  3: 'L',\n  4: 'M',\n  5: 'N',\n  6: 'O',\n  7: 'P',\n  8: 'Q',\n  9: 'R',\n  10: 'S',\n  11: 'T',\n  12: 'C',\n  13: 'U',\n  14: 'V',\n  15: 'W',\n  16: 'X',\n  17: 'Y',\n  18: 'Z',\n  19: 'D',\n  20: 'E',\n  21: 'F',\n  22: 'G',\n  23: 'H',\n  24: 'I',\n  25: 'J'\n}\nfunction getPredict(landmarks) {\n  // console.log(\"landmarks: \", landmarks)\n  // const nodePickle = require('node-pickle');\n  // nodePickle.load(pickledData)\n  var data_input = []\n  var data_input_x = []\n  var data_input_y = []\n  for (var i in landmarks) {\n    // console.log()\n    var x = landmarks[i].x\n    var y = landmarks[i].y\n    data_input_x.push(x)\n    data_input_y.push(y)\n\n  }\n\n\n  for (var j in landmarks) {\n    var x = landmarks[j].x\n    var y = landmarks[j].y\n    // console.log(x)\n    // console.log(Math.min(data_input_x))\n    data_input.push(x - Math.min(...data_input_x));\n    data_input.push(y - Math.min(...data_input_y));\n  }\n  // console.log(data_input)\n  let pred = score(data_input);\n  let z = Math.max(...pred)\n  // console.log()\n  let l = pred.indexOf(z)\n  // console.log(word_dict[l])\n  return word_dict[l]\n  // console.log(pred)\n  // console.log(\"Prediction results:\",Math.round(pred));\n}\nfunction getHighest(prediction) {\n  for (let i in prediction) {\n    if (prediction[i] > 200) {\n      console.log(prediction[i])\n    }\n  }\n}\nconst MPHands = () => {\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [isStart, setIsStart] = useState(false);\n  let time = {}\n\n  useEffect(() => {\n    console.log(Hands.VERSION);\n    const hands = new Hands({\n      locateFile: (file) => {\n\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1626903359/${file}`;\n      },\n    });\n    hands.setOptions({\n      maxNumHands: 2,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5,\n    });\n    hands.onResults(onResults);\n\n    if (\n      typeof webcamRef.current !== \"undefined\" &&\n      webcamRef.current !== null\n    ) {\n      const camera = new Camera(webcamRef.current.video, {\n        onFrame: async () => {\n          await hands.send({ image: webcamRef.current.video });\n        },\n        width: 1280,\n        height: 720,\n      });\n      camera.start();\n    }\n  }, []);\n  let prediction = {}\n  const onResults = (results) => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, videoWidth, videoHeight);\n    canvasCtx.translate(videoWidth, 0);\n    canvasCtx.scale(-1, 1);\n    canvasCtx.drawImage(\n      results.image,\n      0,\n      0,\n      canvasElement.width,\n      canvasElement.height\n    );\n\n    if (results.multiHandLandmarks) {\n\n      for (const landmarks of results.multiHandLandmarks) {\n        let result = getPredict(landmarks)\n        if (result in prediction) {\n          prediction[result]++\n        } else {\n          prediction[result] = 1\n        }\n        for (let i in prediction) {\n          // console.log(prediction[i])\n          if (prediction[i] > 50) {\n            console.log(\"QQQQQQQQQQQQQ\", i)\n            //在前端显示\n            prediction = {}\n            break\n          }\n\n        }\n\n        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {\n          color: \"#00FF00\",\n          lineWidth: 5,\n        });\n        drawLandmarks(canvasCtx, landmarks, { color: \"#FFFFFF\", lineWidth: 2 });\n      }\n    }\n    canvasCtx.restore();\n  };\n\n\n  const startCamera = () => {\n    console.log(\"enle!\")\n    setIsStart(true)\n  };\n\n  return (\n    <div>\n      {console.log(isStart)}\n      {\n      isStart?(\n      <div>\n        <Webcam\n          audio={false}\n          mirrored={true}\n          ref={webcamRef}\n          style={{\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: \"0\",\n            right: \"0\",\n            textAlign: \"center\",\n            zindex: 9,\n            width: 320,\n            height: 240,\n          }}\n        />\n        <canvas\n          ref={canvasRef}\n          style={{\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: \"0\",\n            right: \"0\",\n            textAlign: \"center\",\n            zindex: 9,\n            width: 320,\n            height: 240,\n          }}\n        ></canvas>\n      </div>):\n      <div></div>\n      }\n\n      <button onClick={startCamera}>Start camera</button>\n    </div>\n  );\n};\n\nexport default MPHands;\n"]},"metadata":{},"sourceType":"module"}