{"ast":null,"code":"var _jsxFileName = \"/Users/suchangcao/study/Northeastern University/2022-9-07(Grad-2-2)/CS 5330/project/react-mediapipe-main/Real-time-American-Sign-language-recognition/src/components/MPHands.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useEffect } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { Hands, HAND_CONNECTIONS } from \"@mediapipe/hands/hands\";\nimport { drawConnectors, drawLandmarks } from \"@mediapipe/drawing_utils/drawing_utils\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport score from \"./Output2\";\nimport pickledData from \"./model.p\"; // let word_dict={0: 'A', \n//                 1: 'B', \n//                 2: 'C', \n//                 3: 'D', \n//                 4: 'E', \n//                 5: 'F', \n//                 6: 'G', \n//                 7: 'H', \n//                 8: 'I', \n//                 9: 'J', \n//                 10: 'K', \n//                 11: 'L', \n//                 12: 'M', \n//                 13: 'N', \n//                 14: 'O', \n//                 15: 'P', \n//                 16: 'Q', \n//                 17: 'R', \n//                 18: 'S', \n//                 19: 'T', \n//                 20: 'U', \n//                 21: 'V', \n//                 22: 'W', \n//                 23: 'X', \n//                 24: 'Y', \n//                 25: 'Z'}\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet word_dict = {\n  0: 'A',\n  1: 'B',\n  2: 'K',\n  3: 'L',\n  4: 'M',\n  5: 'N',\n  6: 'O',\n  7: 'P',\n  8: 'Q',\n  9: 'R',\n  10: 'S',\n  11: 'T',\n  12: 'C',\n  13: 'U',\n  14: 'V',\n  15: 'W',\n  16: 'X',\n  17: 'Y',\n  18: 'Z',\n  19: 'D',\n  20: 'E',\n  21: 'F',\n  22: 'G',\n  23: 'H',\n  24: 'I',\n  25: 'J'\n};\n\nfunction getPredict(landmarks) {\n  // console.log(\"landmarks: \", landmarks)\n  // const nodePickle = require('node-pickle');\n  // nodePickle.load(pickledData)\n  var data_input = [];\n  var data_input_x = [];\n  var data_input_y = [];\n\n  for (var i in landmarks) {\n    // console.log()\n    var x = landmarks[i].x;\n    var y = landmarks[i].y;\n    data_input_x.push(x);\n    data_input_y.push(y);\n  }\n\n  for (var j in landmarks) {\n    var x = landmarks[j].x;\n    var y = landmarks[j].y; // console.log(x)\n    // console.log(Math.min(data_input_x))\n\n    data_input.push(x - Math.min(...data_input_x));\n    data_input.push(y - Math.min(...data_input_y));\n  } // console.log(data_input)\n\n\n  let pred = score(data_input);\n  let z = Math.max(...pred); // console.log()\n\n  let l = pred.indexOf(z); // console.log(word_dict[l])\n\n  return word_dict[l]; // console.log(pred)\n  // console.log(\"Prediction results:\",Math.round(pred));\n}\n\nfunction getHighest(prediction) {\n  for (let i in prediction) {\n    if (prediction[i] > 200) {\n      console.log(prediction[i]);\n    }\n  }\n}\n\nconst MPHands = () => {\n  _s();\n\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  let time = {};\n  useEffect(() => {\n    console.log(Hands.VERSION);\n    const hands = new Hands({\n      locateFile: file => {\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1626903359/${file}`;\n      }\n    });\n    hands.setOptions({\n      maxNumHands: 2,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5\n    });\n    hands.onResults(onResults);\n\n    if (typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null) {\n      const camera = new Camera(webcamRef.current.video, {\n        onFrame: async () => {\n          await hands.send({\n            image: webcamRef.current.video\n          });\n        },\n        width: 1280,\n        height: 720\n      });\n      camera.start();\n    }\n  }, []);\n  let prediction = {};\n\n  const onResults = results => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, videoWidth, videoHeight);\n    canvasCtx.translate(videoWidth, 0);\n    canvasCtx.scale(-1, 1);\n    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);\n\n    if (results.multiHandLandmarks) {\n      for (const landmarks of results.multiHandLandmarks) {\n        let result = getPredict(landmarks);\n\n        if (result in prediction) {\n          prediction[result]++;\n        } else {\n          prediction[result] = 1;\n        }\n\n        for (let i in prediction) {\n          console.log(\"...\");\n\n          if (prediction[i] > 200) {\n            console.log(prediction[i]);\n            prediction = {};\n            break;\n          }\n        }\n\n        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {\n          color: \"#00FF00\",\n          lineWidth: 5\n        });\n        drawLandmarks(canvasCtx, landmarks, {\n          color: \"#FFFFFF\",\n          lineWidth: 2\n        });\n      }\n    }\n\n    canvasCtx.restore();\n  }; // let isStart = false\n  // const startCamera = () => {\n  //   console.log(\"enle!\")\n  //   isStart = true;\n  // };\n\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(Webcam, {\n      audio: false,\n      mirrored: true,\n      ref: webcamRef,\n      style: {\n        position: \"absolute\",\n        marginLeft: \"auto\",\n        marginRight: \"auto\",\n        left: \"0\",\n        right: \"0\",\n        textAlign: \"center\",\n        zindex: 9,\n        width: 320,\n        height: 240\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 203,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: \"absolute\",\n        marginLeft: \"auto\",\n        marginRight: \"auto\",\n        left: \"0\",\n        right: \"0\",\n        textAlign: \"center\",\n        zindex: 9,\n        width: 320,\n        height: 240\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 201,\n    columnNumber: 5\n  }, this);\n};\n\n_s(MPHands, \"v4cpjlVQ0JCDZnPWaD3Z9DHNiTM=\");\n\n_c = MPHands;\nexport default MPHands;\n\nvar _c;\n\n$RefreshReg$(_c, \"MPHands\");","map":{"version":3,"sources":["/Users/suchangcao/study/Northeastern University/2022-9-07(Grad-2-2)/CS 5330/project/react-mediapipe-main/Real-time-American-Sign-language-recognition/src/components/MPHands.js"],"names":["React","useRef","useEffect","Webcam","Hands","HAND_CONNECTIONS","drawConnectors","drawLandmarks","Camera","score","pickledData","word_dict","getPredict","landmarks","data_input","data_input_x","data_input_y","i","x","y","push","j","Math","min","pred","z","max","l","indexOf","getHighest","prediction","console","log","MPHands","webcamRef","canvasRef","time","VERSION","hands","locateFile","file","setOptions","maxNumHands","minDetectionConfidence","minTrackingConfidence","onResults","current","camera","video","onFrame","send","image","width","height","start","results","videoWidth","videoHeight","canvasElement","canvasCtx","getContext","save","clearRect","translate","scale","drawImage","multiHandLandmarks","result","color","lineWidth","restore","position","marginLeft","marginRight","left","right","textAlign","zindex"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { Hands, HAND_CONNECTIONS } from \"@mediapipe/hands/hands\";\nimport {\n  drawConnectors,\n  drawLandmarks,\n} from \"@mediapipe/drawing_utils/drawing_utils\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport score from \"./Output2\"\nimport pickledData from \"./model.p\"\n\n\n// let word_dict={0: 'A', \n//                 1: 'B', \n//                 2: 'C', \n//                 3: 'D', \n//                 4: 'E', \n//                 5: 'F', \n//                 6: 'G', \n//                 7: 'H', \n//                 8: 'I', \n//                 9: 'J', \n//                 10: 'K', \n//                 11: 'L', \n//                 12: 'M', \n//                 13: 'N', \n//                 14: 'O', \n//                 15: 'P', \n//                 16: 'Q', \n//                 17: 'R', \n//                 18: 'S', \n//                 19: 'T', \n//                 20: 'U', \n//                 21: 'V', \n//                 22: 'W', \n//                 23: 'X', \n//                 24: 'Y', \n//                 25: 'Z'}\n\nlet word_dict = {\n  0: 'A',\n  1: 'B',\n  2: 'K',\n  3: 'L',\n  4: 'M',\n  5: 'N',\n  6: 'O',\n  7: 'P',\n  8: 'Q',\n  9: 'R',\n  10: 'S',\n  11: 'T',\n  12: 'C',\n  13: 'U',\n  14: 'V',\n  15: 'W',\n  16: 'X',\n  17: 'Y',\n  18: 'Z',\n  19: 'D',\n  20: 'E',\n  21: 'F',\n  22: 'G',\n  23: 'H',\n  24: 'I',\n  25: 'J'\n}\nfunction getPredict(landmarks){\n          // console.log(\"landmarks: \", landmarks)\n        // const nodePickle = require('node-pickle');\n        // nodePickle.load(pickledData)\n        var data_input = []\n        var data_input_x = []\n        var data_input_y = []\n        for (var i in landmarks) {\n          // console.log()\n          var x = landmarks[i].x\n          var y = landmarks[i].y\n          data_input_x.push(x)\n          data_input_y.push(y)\n\n        }\n\n\n        for (var j in landmarks) {\n          var x = landmarks[j].x\n          var y = landmarks[j].y\n          // console.log(x)\n          // console.log(Math.min(data_input_x))\n          data_input.push(x - Math.min(...data_input_x));\n          data_input.push(y - Math.min(...data_input_y));\n        }\n        // console.log(data_input)\n        let pred = score(data_input);\n        let z = Math.max(...pred)\n        // console.log()\n        let l = pred.indexOf(z)\n        // console.log(word_dict[l])\n        return word_dict[l]\n        // console.log(pred)\n        // console.log(\"Prediction results:\",Math.round(pred));\n}\nfunction getHighest(prediction){\n  for (let i in prediction){\n    if (prediction[i]>200){\n      console.log(prediction[i])\n    }\n  }\n}\nconst MPHands = () => {\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  let time = {}\n\n  useEffect(() => {\n    console.log(Hands.VERSION);\n    const hands = new Hands({\n      locateFile: (file) => {\n\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1626903359/${file}`;\n      },\n    });\n    hands.setOptions({\n      maxNumHands: 2,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5,\n    });\n    hands.onResults(onResults);\n\n    if (\n      typeof webcamRef.current !== \"undefined\" &&\n      webcamRef.current !== null\n    ) {\n      const camera = new Camera(webcamRef.current.video, {\n        onFrame: async () => {\n          await hands.send({ image: webcamRef.current.video });\n        },\n        width: 1280,\n        height: 720,\n      });\n      camera.start();\n    }\n  }, []);\n  let prediction = {}\n  const onResults = (results) => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, videoWidth, videoHeight);\n    canvasCtx.translate(videoWidth, 0);\n    canvasCtx.scale(-1, 1);\n    canvasCtx.drawImage(\n      results.image,\n      0,\n      0,\n      canvasElement.width,\n      canvasElement.height\n    );\n    \n    if (results.multiHandLandmarks) {\n\n      for (const landmarks of results.multiHandLandmarks) {\n        let result = getPredict(landmarks)\n        if (result in prediction){\n          prediction[result]++\n        }else{\n          prediction[result] = 1\n        }\n        for (let i in prediction){\n          console.log(\"...\")\n          if (prediction[i]>200){\n            console.log(prediction[i])\n            prediction = {}\n            break\n          }\n\n        }\n\n        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {\n          color: \"#00FF00\",\n          lineWidth: 5,\n        });\n        drawLandmarks(canvasCtx, landmarks, { color: \"#FFFFFF\", lineWidth: 2 });\n      }\n    }\n    canvasCtx.restore();\n  };\n\n  // let isStart = false\n  // const startCamera = () => {\n  //   console.log(\"enle!\")\n  //   isStart = true;\n  // };\n\n  return (\n    <div>\n      \n        <Webcam\n          audio={false}\n          mirrored={true}\n          ref={webcamRef}\n          style={{\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: \"0\",\n            right: \"0\",\n            textAlign: \"center\",\n            zindex: 9,\n            width: 320,\n            height: 240,\n          }}\n        />\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: \"absolute\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          left: \"0\",\n          right: \"0\",\n          textAlign: \"center\",\n          zindex: 9,\n          width: 320,\n          height: 240,\n        }}\n      ></canvas>\n\n      {/* <button onClick={startCamera}>Start camera</button> */}\n    </div>\n  );\n};\n\nexport default MPHands;\n"]},"metadata":{},"sourceType":"module"}