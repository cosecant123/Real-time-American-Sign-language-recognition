{"ast":null,"code":"var _jsxFileName = \"/Users/suchangcao/study/Northeastern University/2022-9-07(Grad-2-2)/CS 5330/project/react-mediapipe-main/src/components/MPHands.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useEffect } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { Hands, HAND_CONNECTIONS } from \"@mediapipe/hands/hands\";\nimport { drawConnectors, drawLandmarks } from \"@mediapipe/drawing_utils/drawing_utils\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport score from \"./ASLmodel\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst MPHands = () => {\n  _s();\n\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    console.log(Hands.VERSION);\n    const hands = new Hands({\n      locateFile: file => {\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1626903359/${file}`;\n      }\n    });\n    hands.setOptions({\n      maxNumHands: 2,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5\n    });\n    hands.onResults(onResults);\n\n    if (typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null) {\n      const camera = new Camera(webcamRef.current.video, {\n        onFrame: async () => {\n          await hands.send({\n            image: webcamRef.current.video\n          });\n        },\n        width: 1280,\n        height: 720\n      });\n      camera.start();\n    }\n  }, []);\n\n  const onResults = results => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, videoWidth, videoHeight);\n    canvasCtx.translate(videoWidth, 0);\n    canvasCtx.scale(-1, 1);\n    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);\n\n    if (results.multiHandLandmarks) {\n      for (const landmarks of results.multiHandLandmarks) {\n        // console.log(\"landmarks: \", landmarks)\n        var data_input = [];\n        var data_input_x = [];\n        var data_input_y = [];\n\n        for (var i in landmarks) {\n          // console.log()\n          var x = landmarks[i].x;\n          var y = landmarks[i].y;\n          data_input_x.push(x);\n          data_input_y.push(y); // let x = landmarks[i].x\n          // let y = landmarks[i].y\n          // data_input.push(x - Math.min(...x_));\n          // data_input.push(y - Math.min(...y_));\n        }\n\n        for (var j in landmarks) {\n          var x = landmarks[i].x;\n          var y = landmarks[i].y;\n          data_input.push(x - Math.min(data_input_x));\n          data_input.push(y - Math.min(data_input_y));\n        }\n\n        console.log(score(data_input));\n        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {\n          color: \"#00FF00\",\n          lineWidth: 5\n        });\n        drawLandmarks(canvasCtx, landmarks, {\n          color: \"#FFFFFF\",\n          lineWidth: 2\n        });\n      }\n    }\n\n    canvasCtx.restore();\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(Webcam, {\n      audio: false,\n      mirrored: true,\n      ref: webcamRef,\n      style: {\n        position: \"absolute\",\n        marginLeft: \"auto\",\n        marginRight: \"auto\",\n        left: \"0\",\n        right: \"0\",\n        textAlign: \"center\",\n        zindex: 9,\n        width: 800,\n        height: 600\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: \"absolute\",\n        marginLeft: \"auto\",\n        marginRight: \"auto\",\n        left: \"0\",\n        right: \"0\",\n        textAlign: \"center\",\n        zindex: 9,\n        width: 800,\n        height: 600\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 99,\n    columnNumber: 5\n  }, this);\n};\n\n_s(MPHands, \"v4cpjlVQ0JCDZnPWaD3Z9DHNiTM=\");\n\n_c = MPHands;\nexport default MPHands;\n\nvar _c;\n\n$RefreshReg$(_c, \"MPHands\");","map":{"version":3,"sources":["/Users/suchangcao/study/Northeastern University/2022-9-07(Grad-2-2)/CS 5330/project/react-mediapipe-main/src/components/MPHands.js"],"names":["React","useRef","useEffect","Webcam","Hands","HAND_CONNECTIONS","drawConnectors","drawLandmarks","Camera","score","MPHands","webcamRef","canvasRef","console","log","VERSION","hands","locateFile","file","setOptions","maxNumHands","minDetectionConfidence","minTrackingConfidence","onResults","current","camera","video","onFrame","send","image","width","height","start","results","videoWidth","videoHeight","canvasElement","canvasCtx","getContext","save","clearRect","translate","scale","drawImage","multiHandLandmarks","landmarks","data_input","data_input_x","data_input_y","i","x","y","push","j","Math","min","color","lineWidth","restore","position","marginLeft","marginRight","left","right","textAlign","zindex"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { Hands, HAND_CONNECTIONS } from \"@mediapipe/hands/hands\";\nimport {\n  drawConnectors,\n  drawLandmarks,\n} from \"@mediapipe/drawing_utils/drawing_utils\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport score from \"./ASLmodel\"\n\nconst MPHands = () => {\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    console.log(Hands.VERSION);\n    const hands = new Hands({\n      locateFile: (file) => {\n        \n        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1626903359/${file}`;\n      },\n    });\n    hands.setOptions({\n      maxNumHands: 2,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5,\n    });\n    hands.onResults(onResults);\n\n    if (\n      typeof webcamRef.current !== \"undefined\" &&\n      webcamRef.current !== null\n    ) {\n      const camera = new Camera(webcamRef.current.video, {\n        onFrame: async () => {\n          await hands.send({ image: webcamRef.current.video });\n        },\n        width: 1280,\n        height: 720,\n      });\n      camera.start();\n    }\n  }, []);\n\n  const onResults = (results) => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, videoWidth, videoHeight);\n    canvasCtx.translate(videoWidth, 0);\n    canvasCtx.scale(-1, 1);\n    canvasCtx.drawImage(\n      results.image,\n      0,\n      0,\n      canvasElement.width,\n      canvasElement.height\n    );\n    if (results.multiHandLandmarks) {\n      \n      for (const landmarks of results.multiHandLandmarks) {\n        // console.log(\"landmarks: \", landmarks)\n        var data_input = []\n        var data_input_x = []\n        var data_input_y = []\n        for (var i in landmarks){\n          // console.log()\n          var x= landmarks[i].x\n          var y=landmarks[i].y\n          data_input_x.push(x)\n          data_input_y.push(y)\n          // let x = landmarks[i].x\n          // let y = landmarks[i].y\n          // data_input.push(x - Math.min(...x_));\n          // data_input.push(y - Math.min(...y_));\n        }\n        for (var j in landmarks){\n          var x= landmarks[i].x\n          var y=landmarks[i].y\n          data_input.push(x - Math.min(data_input_x));\n          data_input.push(y - Math.min(data_input_y));\n        }\n        console.log(score(data_input))\n        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {\n          color: \"#00FF00\",\n          lineWidth: 5,\n        });\n        drawLandmarks(canvasCtx, landmarks, { color: \"#FFFFFF\", lineWidth: 2 });\n      }\n    }\n    canvasCtx.restore();\n  };\n\n  return (\n    <div>\n      <Webcam\n        audio={false}\n        mirrored={true}\n        ref={webcamRef}\n        style={{\n          position: \"absolute\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          left: \"0\",\n          right: \"0\",\n          textAlign: \"center\",\n          zindex: 9,\n          width: 800,\n          height: 600,\n        }}\n      />\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: \"absolute\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          left: \"0\",\n          right: \"0\",\n          textAlign: \"center\",\n          zindex: 9,\n          width: 800,\n          height: 600,\n        }}\n      ></canvas>\n    </div>\n  );\n};\n\nexport default MPHands;\n"]},"metadata":{},"sourceType":"module"}